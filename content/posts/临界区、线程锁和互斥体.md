---
title: "临界区、线程锁和互斥体"
categories: [ "win32" ]
tags: [ "win32" ]
draft: false
slug: "临界区、线程锁和互斥体-临界区线程锁和互斥体"
date: "2018-04-18 03:05:41"
---



# 临界区、线程锁和互斥体

## 不可重入函数

不可重入函数: 当这个函数返回前，不可以被其他线程调用

原因：

    printf : 访问了引用全局变量stdout
    malloc : 引用了全局内存分配表
    free   : 引用的全局内存分配表
    

类似的 假如我在我的线程中使用全局变量会不会出现类似问题？

坑：

当多线程同时去访问所谓不可重入函数的时候，当A线程调用printf执行完毕之前，发生了线程切换去执行B线程，而B线程如果又再等待A线程的时候，那么就会有几率触发bug，永久等待。。。。

## 临界区 -共享资源

![][1] 

比如上图

尽管A B C D 四个线程都回去访问全局变量。而且在访问一半的时候有可能会出现线程上下文切换。但是我们在变量前面加了一把锁，比如A线程访问一半时 发生了线程切换。此时B线程再去访问也是无法访问的。等线程切换回A 之后 A 访问完毕释放。其他线程才可以正常访问

有多个线程同时使用的变量，我们称为临界变量

## 同一进程中，不同线程的共享资源访问解决办法：线程锁

![][2] 

如左图，当A线程访问共享资源使用一半的时候，如果发生线程切换，B线程去访问并修改了共享资源，那么切换回A的时候拿到的值必然是错误的。

如何简单的解决这种问题？

此时引入线程锁的概念：

当 线程访问共享资源的时候 需要取得锁，取得锁的才可以访问资源，访问完毕后释放锁，其他线程才可以访问

  * 创建全局变量
    
        CRITICAL_SECTION cs;            //创建令牌

  * 初始化全局变量
    
        InitializeCriticalSection(&cs); //初始化令牌

  * 实现临界区
    
        EnterCriticalSection(&cs);      //进入临界区
        LeaveCriticalSection(&cs);      //离开临界区

## 跨进程访问共享资源 ：互斥体

![][3] 

线程间可以通过线程锁来防止发生错误，进程间也可以通过锁来限制

这就是互斥体

![][4] 

因为需要跨进程加锁，所以互斥体不能存在用户区中。只能存在于同时访问共享资源的共享内核区

![][5] 

常用的互斥体的操作：

    
    //创建互斥体
    HANDLE CreateMutex
    (
        LPSECURITY_ATTRIBUTES lpMutexAttributes,  // 安全属性
        BOOL bInitialOwner,                       // 初始信号
        LPCTSTR lpName                            // 对象名称
    );
    //等待信号到达
    DWORD WaitForSingleObject
    (
        HANDLE hHandle,                           // 等待对象的句柄
        DWORD dwMilliseconds                      // 超时时间
    );
    //释放互斥体
    BOOL ReleaseMutex
    ( 
      HANDLE hMutex                              // 释放的内核对象
    );

  1. 加入A进程先创建的互斥体，那么B进程如何找到A创建的互斥体？
  2. 加入我们不能确定AB两个进程谁先启动，那么由会来先创建我们的互斥体？谁后来打开前者创建的互斥体？
    
        一个进程调用<code>CreateMutex 时候如果内核中没有名字为参数lpName的互斥体的时候，系统就会创建对象，不并且返回句柄。当其他进程中的线程访问的时候，也调用CreateMutex，并且lpName 参数与前面调用的进程相同的时候，在内核区中已经有此名字的互斥体，此时不会创建新对象，会直接返回之前内核中创建好的对象
        </code>

## 线程锁与互斥体的区别

线程锁与互斥体的区别：

  1. 线程锁只能用于单个进程内部的线程控制
  2. 互斥体可以设定等待超时，但线程锁不能
  3. 线程意外终结时，Mutex可以避免无限等待
  4. Mutex效率没有线程锁高

 [1]: /uploads/oss/2018-04-18-15238997509971.jpg ""
 [2]: /uploads/oss/2018-04-18-15239870834892.jpg ""
 [3]: /uploads/oss/2018-04-18-15239875337223.jpg ""
 [4]: /uploads/oss/2018-04-18-15239881424112.jpg ""
 [5]: /uploads/oss/2018-04-18-15239883982293.jpg ""