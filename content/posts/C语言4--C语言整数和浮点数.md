---
title: "C语言4 -C语言整数和浮点数"
categories: [ "汇编","C-lang" ]
tags: [ "C" ]
draft: false
slug: "C语言4 -C语言整数和浮点数-c语言4-c语言整数和浮点数"
date: "2017-12-24 09:39:00"
---



## C语言数据类型

### 基本类型

#### 整数类型

    char、short、int、long
    char    8BIT    1字节     0~0xFF
    short   16BIT   2字节     0~0xFFFF
    int     32BIT   4字节     0~0xFFFFFFFF
    long    32BIT   4字节     0~0xFFFFFFFF

特别说明：  
int 在16位计算机中与short宽度一样，在32位以上的计算机中与long相同

##### 存储格式

    char x = 1;         //0000 0001  0x01
    char x = -1;        //1111 1111 0xFF
    （反码、补码、源码规则存储）

##### 数据溢出

    char x = 0xFF;      //1111 1111
    char Y = 0X100;     //0001 0000 0000 （char最多8位 此处溢出了）

数据溢出，是吧高位舍弃还是低位舍弃？

> 经过实验，发现直接丢弃高位

##### 有符号数与无符号数(signed、unsigned)

  1. 什么时候使用有符号数 无符号数
    
        sinned char x = ;   //0000 0000  0到127、-128到-1
        printf("&u \n",x); 按无符号数输出打印
        printf("&d \n",x); 按有符号数输出打印
        unsinned char x = ;   //0000 0000  0到255 

  2. 有符号数与无符号数的区别
    
      * 正确理解有符号数与无符号数
      * 扩展时与比较时才有区别
    
    扩展
    
        signed char x = -1; //0xFF 1111 1111
        int y =x; // 1111 1111 1111 1111 1111 1111 1111 1111 0xFFFF FFFF
        signed char x = 127; //0x7F 0111 1111
        int y =x; // 0000 0000 0000 0000 0000 0000 0111 1111 0xFFFF FFFF
        unsigned char x = -1;   // 0xFF 1111 1111
        int y = x; // 0000 0000 0000 0000 0000 0000 1110 1111 0x0000 00FF  
    
    比较
    
        unsigned char x = -1; //0xFF
        unsigned char y = 1;  //0X01
        if(x > y)
        {
          printf("x>y \n");  //成立
        }
        char x = -1;        //0XFF
        char y = 1;         //0X01
        if(x > y)
        {
          printf("x>y \n");  //不成立
        }

#### 浮点类型

##### 声明方式

    float           4字节
    double          8字节
    long double     8字节(某些平台的编译器可能是16个字节)
    赋值:
    float x = 1.23;
    double d = 2.34;
    long double d = 2.34;
    建议:
    float x = 1.23F;
    double d = 2.34;
    long double d = 2.34L;

##### 浮点类型的存储格式

float和double在存储方式上都是村从 IEEE 编码规范的

![][1] 

##### 十进制整数转二进制

8.25转成浮点存储：整数部分

![][2] 

总结：  
所有的整数一定可以完整转换成2进制

8.25转成浮点存储：小数部分

![][3] 

总结：  
用二进制描述小数，不可能做到完全精确  
就好比用10进制来表示1/3也不可能完全精确是一个道理。

##### 将一个float型转化为内存存储格式的步骤为:

  1. 先将这个实数的绝对值化为二进制格式
  2. 将这个二进制格式的实数的小数点左移或者右移N位，直到小数点移动到第一个有效数字的右边
  3. 从小数点右边第一位开始数出二十三位数字放入第22到第0位
  4. 如果实数是正的，则第31位放入“0”，否则放入 “1”
  5. 如果n是左移得到的，说明指数是正的，第30位放入“1”，如果n是右移得到的或n=0，则第30位放入“0”
  6. 如果n是左移得到的，则n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位
  7. 如果n是右移得到的或n=0,则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位

麻痹太复杂了

    8.25 -> 100.01  -> 1.00001 * 2的三次方(指数是3)
    科学计数法
    10      =   1 * 10一次方      指数:1
    100     =   1 * 10的二次方    指数:2
    1000    =   1 * 10的三次方    指数:3
    填充表格(flot)
    符号位(1)  指数部分(8)     尾数部分(23)
    0         10000010       000 0100 0000 0000 0000 0000
    16进制表示: 0x4104 0000
    尾数部分：经过第一步转换后 8.25等于
    1.00001 * 2的三次方(指数是3)
    尾数直接从前往后放所以尾数是：
    000 0100 0000 0000 0000 0000
    指数部分：
    首位表示小数点移动方向
    向左移动则为1，向右为0
    指数部分简单方法:
    不论左移还是右移。一律吧指数 +127 然后取2进制
    左移了三次,指数为3,3的二进制是11, 但是这里要减去1（不知道为啥？？）
    所以指数部分为 1000 0010

练习:  
将0.25转换为内存中存储的二进制数

（简单方法，不管指数是正数还是负数，一律加127 转换二进制填进去。。）

    0.25 = 1 * 2的-2次方  指数为-2 指数 加 127 = 125 = 01111101
    尾数 都是0
    所以是小数点向右移动 所以指数首位为0
    向右移动两位  所以 指数剩下的为 10，这里要减去1 所以为1
    结果：
    0 10000001 000 0000 0000 0000 0000 0000
    0 01111101 000
    

##### 浮点类型的精度

float和double的精度是由尾数的位数来决定的  
float : 2^23 = 8388608 一共7位，这意味着最多能有7位有效数字；  
double : 2^52 = 4503599627370496 一共16位，这意味着最多能用16位有效数字；

 [1]: /uploads/oss/2017-12-19-15136940352445.jpg ""
 [2]: /uploads/oss/2017-12-19-15136942261720.jpg ""
 [3]: /uploads/oss/2017-12-19-15136944642618.jpg ""